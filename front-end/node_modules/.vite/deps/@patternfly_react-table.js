import {
  inline_edit_default
} from "./chunk-DJHFGRQO.js";
import {
  require_Stack,
  require_baseAssignValue,
  require_baseFor,
  require_baseRest,
  require_cloneBuffer,
  require_cloneTypedArray,
  require_copyArray,
  require_copyObject,
  require_eq,
  require_initCloneObject,
  require_isArguments,
  require_isArray,
  require_isArrayLike,
  require_isBuffer,
  require_isFunction,
  require_isIterateeCall,
  require_isPlainObject,
  require_isTypedArray,
  require_keysIn
} from "./chunk-M7PMBLXN.js";
import {
  require_isObject,
  require_isObjectLike
} from "./chunk-BKAPQJPN.js";
import {
  ActionList,
  ActionListItem,
  Button,
  Checkbox,
  Divider,
  Dropdown,
  DropdownItem,
  DropdownList,
  KeyTypes,
  MenuToggle,
  Popover,
  Select,
  SelectList,
  TextInput,
  Tooltip,
  canUseDOM,
  check_default,
  debounce,
  form_default,
  handleArrows,
  setTabIndex,
  useOUIAProps
} from "./chunk-3ZFVOHVH.js";
import {
  css
} from "./chunk-XII3G3RY.js";
import "./chunk-KPD4VVXB.js";
import {
  arrows_alt_v_icon_default,
  ellipsis_h_icon_default,
  ellipsis_v_icon_default,
  help_icon_default,
  long_arrow_alt_down_icon_default,
  long_arrow_alt_up_icon_default,
  pencil_alt_icon_default
} from "./chunk-57IQ6C75.js";
import {
  angle_down_icon_default,
  check_icon_default,
  grip_vertical_icon_default,
  star_icon_default,
  times_icon_default
} from "./chunk-EXTB5LCW.js";
import "./chunk-K5CUF6QK.js";
import "./chunk-5PIYFGH3.js";
import {
  __rest
} from "./chunk-JZG3KGFP.js";
import {
  require_jsx_runtime
} from "./chunk-IULEFUF5.js";
import {
  require_react
} from "./chunk-I773Y2XN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/lodash/mergeWith.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module.exports = mergeWith2;
  }
});

// node_modules/@patternfly/react-table/dist/esm/components/Table/ActionsColumn.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var ActionsColumnBase = (_a) => {
  var { items, isDisabled, rowData, extraData, actionsToggle, popperProps = {
    position: "end",
    direction: "down"
  }, innerRef, firstActionItemRef, isOnOpenChangeDisabled = false } = _a, props = __rest(_a, ["items", "isDisabled", "rowData", "extraData", "actionsToggle", "popperProps", "innerRef", "firstActionItemRef", "isOnOpenChangeDisabled"]);
  const [isOpen, setIsOpen] = (0, import_react2.useState)(false);
  const onToggle = () => {
    setIsOpen(!isOpen);
  };
  const onActionClick = (event, onClick) => {
    if (onClick) {
      event.preventDefault();
      onClick(event, extraData && extraData.rowIndex, rowData, extraData);
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [items.filter((item) => item.isOutsideDropdown).map((_a2, key) => {
    var { title, itemKey, onClick, isOutsideDropdown } = _a2, props2 = __rest(_a2, ["title", "itemKey", "onClick", "isOutsideDropdown"]);
    return typeof title === "string" ? (0, import_react.createElement)(Button, Object.assign({ onClick: (event) => onActionClick(event, onClick) }, props2, { isDisabled, key: itemKey || `outside_dropdown_${key}`, "data-key": itemKey || `outside_dropdown_${key}` }), title) : (0, import_react2.cloneElement)(title, Object.assign({ onClick, isDisabled }, props2));
  }), (0, import_jsx_runtime.jsx)(Dropdown, Object.assign({ isOpen, onOpenChange: !isOnOpenChangeDisabled ? (isOpen2) => setIsOpen(isOpen2) : void 0, toggle: (toggleRef) => actionsToggle ? actionsToggle({ onToggle, isOpen, isDisabled, toggleRef }) : (0, import_jsx_runtime.jsx)(MenuToggle, { "aria-label": "Kebab toggle", ref: toggleRef, onClick: onToggle, isExpanded: isOpen, isDisabled, variant: "plain", icon: (0, import_jsx_runtime.jsx)(ellipsis_v_icon_default, {}) }) }, rowData && rowData.actionProps, { ref: innerRef }, props, { popperProps, children: (0, import_jsx_runtime.jsx)(DropdownList, { children: items.filter((item) => !item.isOutsideDropdown).map((_a2, index) => {
    var { title, itemKey, onClick, tooltipProps, isSeparator, shouldCloseOnClick = true } = _a2, props2 = __rest(_a2, ["title", "itemKey", "onClick", "tooltipProps", "isSeparator", "shouldCloseOnClick"]);
    if (isSeparator) {
      return (0, import_jsx_runtime.jsx)(Divider, { "data-key": itemKey || index }, itemKey || index);
    }
    const item = (0, import_react.createElement)(DropdownItem, Object.assign({ onClick: (event) => {
      onActionClick(event, onClick);
      shouldCloseOnClick && onToggle();
    } }, props2, { key: itemKey || index, "data-key": itemKey || index, ref: index === 0 ? firstActionItemRef : void 0 }), title);
    if (tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.content) {
      return (0, import_jsx_runtime.jsx)(Tooltip, Object.assign({}, tooltipProps, { children: item }), itemKey || index);
    } else {
      return item;
    }
  }) }) }))] });
};
var ActionsColumn = (0, import_react2.forwardRef)((props, ref) => (0, import_jsx_runtime.jsx)(ActionsColumnBase, Object.assign({}, props, { innerRef: ref })));
ActionsColumn.displayName = "ActionsColumn";

// node_modules/@patternfly/react-table/dist/esm/components/Table/CollapseColumn.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Table/table.mjs
import "C:/Users/guillaumehouthoofd/Documents/Benoit/Epreuve_intégrée/ClubManager/front-end/node_modules/@patternfly/react-styles/css/components/Table/table.css";
var table_default = {
  "button": "pf-v6-c-button",
  "check": "pf-v6-c-check",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "fixed": "pf-m-fixed",
    "stickyHeader": "pf-m-sticky-header",
    "nestedColumnHeader": "pf-m-nested-column-header",
    "striped": "pf-m-striped",
    "expandable": "pf-m-expandable",
    "stripedEven": "pf-m-striped-even",
    "ghostRow": "pf-m-ghost-row",
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "center": "pf-m-center",
    "help": "pf-m-help",
    "favorite": "pf-m-favorite",
    "borderRight": "pf-m-border-right",
    "borderLeft": "pf-m-border-left",
    "noBorderRows": "pf-m-no-border-rows",
    "expanded": "pf-m-expanded",
    "clickable": "pf-m-clickable",
    "selected": "pf-m-selected",
    "firstCellOffsetReset": "pf-m-first-cell-offset-reset",
    "dragOver": "pf-m-drag-over",
    "truncate": "pf-m-truncate",
    "wrap": "pf-m-wrap",
    "nowrap": "pf-m-nowrap",
    "fitContent": "pf-m-fit-content",
    "breakWord": "pf-m-break-word",
    "standalone": "pf-m-standalone",
    "favorited": "pf-m-favorited",
    "noPadding": "pf-m-no-padding",
    "compact": "pf-m-compact",
    "borderRow": "pf-m-border-row",
    "width_10": "pf-m-width-10",
    "width_15": "pf-m-width-15",
    "width_20": "pf-m-width-20",
    "width_25": "pf-m-width-25",
    "width_30": "pf-m-width-30",
    "width_35": "pf-m-width-35",
    "width_40": "pf-m-width-40",
    "width_45": "pf-m-width-45",
    "width_50": "pf-m-width-50",
    "width_60": "pf-m-width-60",
    "width_70": "pf-m-width-70",
    "width_80": "pf-m-width-80",
    "width_90": "pf-m-width-90",
    "width_100": "pf-m-width-100"
  },
  "radio": "pf-v6-c-radio",
  "table": "pf-v6-c-table",
  "tableAction": "pf-v6-c-table__action",
  "tableButton": "pf-v6-c-table__button",
  "tableButtonContent": "pf-v6-c-table__button-content",
  "tableCaption": "pf-v6-c-table__caption",
  "tableCellEmpty": "pf-v6-c-table__cell-empty",
  "tableCheck": "pf-v6-c-table__check",
  "tableColumnHelp": "pf-v6-c-table__column-help",
  "tableColumnHelpAction": "pf-v6-c-table__column-help-action",
  "tableCompoundExpansionToggle": "pf-v6-c-table__compound-expansion-toggle",
  "tableControlRow": "pf-v6-c-table__control-row",
  "tableDraggable": "pf-v6-c-table__draggable",
  "tableExpandableRow": "pf-v6-c-table__expandable-row",
  "tableExpandableRowContent": "pf-v6-c-table__expandable-row-content",
  "tableFavorite": "pf-v6-c-table__favorite",
  "tableIcon": "pf-v6-c-table__icon",
  "tableIconInline": "pf-v6-c-table__icon-inline",
  "tableInlineEditAction": "pf-v6-c-table__inline-edit-action",
  "tableSort": "pf-v6-c-table__sort",
  "tableSortIndicator": "pf-v6-c-table__sort-indicator",
  "tableSubhead": "pf-v6-c-table__subhead",
  "tableTbody": "pf-v6-c-table__tbody",
  "tableTd": "pf-v6-c-table__td",
  "tableText": "pf-v6-c-table__text",
  "tableTh": "pf-v6-c-table__th",
  "tableThead": "pf-v6-c-table__thead",
  "tableToggle": "pf-v6-c-table__toggle",
  "tableToggleIcon": "pf-v6-c-table__toggle-icon",
  "tableTr": "pf-v6-c-table__tr"
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/CollapseColumn.js
var CollapseColumn = (_a) => {
  var { className = "", children = null, isOpen, onToggle } = _a, props = __rest(_a, ["className", "children", "isOpen", "onToggle"]);
  return (0, import_jsx_runtime2.jsxs)(import_react3.Fragment, { children: [isOpen !== void 0 && (0, import_jsx_runtime2.jsx)(Button, Object.assign({ className: css(className, isOpen && table_default.modifiers.expanded) }, props, { variant: "plain", "aria-label": props["aria-label"] || "Details", onClick: onToggle, "aria-expanded": isOpen, icon: (0, import_jsx_runtime2.jsx)("div", { className: css(table_default.tableToggleIcon), children: (0, import_jsx_runtime2.jsx)(angle_down_icon_default, {}) }) })), children] });
};
CollapseColumn.displayName = "CollapseColumn";

// node_modules/@patternfly/react-table/dist/esm/components/Table/DraggableCell.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var DraggableCell = (_a) => {
  var { className, onClick, "aria-label": ariaLabel, id } = _a, props = __rest(_a, ["className", "onClick", "aria-label", "id"]);
  return (0, import_jsx_runtime3.jsx)(Button, Object.assign({ id, variant: "plain", className, type: "button", "aria-label": ariaLabel || `Draggable row draggable button`, onClick }, props, { icon: (0, import_jsx_runtime3.jsx)(grip_vertical_icon_default, {}) }));
};
DraggableCell.displayName = "DraggableCell";

// node_modules/@patternfly/react-table/dist/esm/components/Table/EditableSelectInputCell.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());
var EditableSelectInputCell = ({ value, rowIndex, cellIndex, onSelect = () => {
}, clearSelection, isOpen = false, isPlaceholder = false, onToggle = () => {
}, selections = [""], options = [], props }) => {
  const onSelectHandler = (event, newValue) => {
    onSelect(event, newValue, rowIndex, cellIndex, isPlaceholder);
  };
  const onClear = (event) => {
    clearSelection(event, rowIndex, cellIndex);
  };
  const select = (0, import_jsx_runtime4.jsx)(Select, Object.assign({ onSelect: onSelectHandler }, clearSelection && { onClear }, { isOpen, selected: selections, toggle: (toggleRef) => (0, import_jsx_runtime4.jsx)(MenuToggle, { ref: toggleRef, onClick: onToggle, isExpanded: isOpen, isPlaceholder, children: isOpen ? "Expanded" : "Collapsed" }) }, props.editableSelectProps, { children: (0, import_jsx_runtime4.jsx)(SelectList, { children: options }) }));
  return (0, import_jsx_runtime4.jsxs)(import_react4.Fragment, { children: [(0, import_jsx_runtime4.jsx)("div", { className: inline_edit_default.inlineEditValue, children: Array.isArray(value) ? value.join(", ") : value }), (0, import_jsx_runtime4.jsxs)("div", { className: inline_edit_default.inlineEditInput, children: [select, (0, import_jsx_runtime4.jsx)("div", { className: css(form_default.formHelperText), "aria-live": "polite", children: props.errorText })] })] });
};
EditableSelectInputCell.displayName = "EditableSelectInputCell";

// node_modules/@patternfly/react-table/dist/esm/components/Table/EditableTextCell.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());
var EditableTextCell = ({ value, rowIndex, cellIndex, props, handleTextInputChange, inputAriaLabel, isDisabled = false }) => (0, import_jsx_runtime5.jsxs)(import_react5.Fragment, { children: [(0, import_jsx_runtime5.jsx)("div", { className: inline_edit_default.inlineEditValue, children: value }), (0, import_jsx_runtime5.jsxs)("div", { className: inline_edit_default.inlineEditInput, children: [(0, import_jsx_runtime5.jsx)(TextInput, { isDisabled, value: props.editableValue !== void 0 ? props.editableValue : value, validated: props.isValid !== false ? "default" : "error", type: "text", onChange: (event, newValue) => {
  handleTextInputChange(newValue, event, rowIndex, cellIndex);
}, "aria-label": inputAriaLabel }), (0, import_jsx_runtime5.jsx)("div", { className: css(form_default.formHelperText), "aria-live": "polite", children: props.errorText })] })] });
EditableTextCell.displayName = "EditableTextCell";

// node_modules/@patternfly/react-table/dist/esm/components/Table/ExpandableRowContent.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var ExpandableRowContent = (_a) => {
  var { children = null } = _a, props = __rest(_a, ["children"]);
  return (0, import_jsx_runtime6.jsx)("div", Object.assign({}, props, { className: css(table_default.tableExpandableRowContent), children }));
};
ExpandableRowContent.displayName = "ExpandableRowContent";

// node_modules/@patternfly/react-table/dist/esm/components/Table/HeaderCellInfoWrapper.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-table/dist/esm/components/Table/TableText.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
var TableTextVariant;
(function(TableTextVariant2) {
  TableTextVariant2["div"] = "div";
  TableTextVariant2["nav"] = "nav";
})(TableTextVariant || (TableTextVariant = {}));
var WrapModifier;
(function(WrapModifier2) {
  WrapModifier2["wrap"] = "wrap";
  WrapModifier2["nowrap"] = "nowrap";
  WrapModifier2["truncate"] = "truncate";
  WrapModifier2["breakWord"] = "breakWord";
  WrapModifier2["fitContent"] = "fitContent";
})(WrapModifier || (WrapModifier = {}));
var TableText = (_a) => {
  var { children = null, className = "", variant = "span", wrapModifier = null, tooltip: tooltipProp = "", tooltipProps = {}, onMouseEnter: onMouseEnterProp = () => {
  }, focused = false, tooltipHasDefaultBehavior = false } = _a, props = __rest(_a, ["children", "className", "variant", "wrapModifier", "tooltip", "tooltipProps", "onMouseEnter", "focused", "tooltipHasDefaultBehavior"]);
  const Component2 = variant;
  const textRef = (0, import_react6.createRef)();
  const [tooltip, setTooltip] = (0, import_react6.useState)(tooltipProp);
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      setTooltip(tooltipProp || event.target.innerText);
    } else {
      setTooltip("");
    }
    onMouseEnterProp(event);
  };
  const onFocus = (element) => {
    if (element.offsetWidth < element.scrollWidth) {
      setTooltip(tooltipProp || element.innerText);
    } else {
      setTooltip("");
    }
  };
  const text = (0, import_jsx_runtime7.jsx)(Component2, Object.assign({ ref: textRef, onMouseEnter: !tooltipHasDefaultBehavior ? onMouseEnter : void 0, className: css(className, wrapModifier && table_default.modifiers[wrapModifier], table_default.tableText) }, props, { children }));
  (0, import_react6.useEffect)(() => {
    if (!tooltipHasDefaultBehavior) {
      if (focused) {
        onFocus(textRef.current);
      } else {
        setTooltip("");
      }
    }
  }, [focused, tooltipHasDefaultBehavior]);
  return tooltip !== "" ? (0, import_jsx_runtime7.jsx)(Tooltip, Object.assign({ triggerRef: textRef, content: tooltip }, !tooltipHasDefaultBehavior && { isVisible: true }, tooltipProps, { children: text })) : text;
};
TableText.displayName = "TableText";

// node_modules/@patternfly/react-table/dist/esm/components/Table/HeaderCellInfoWrapper.js
var HeaderCellInfoWrapper = ({ children, info: info2, className, variant = "tooltip", popoverProps, tooltipProps, ariaLabel }) => (0, import_jsx_runtime8.jsxs)("div", { className: css(table_default.tableColumnHelp, className), children: [typeof children === "string" ? (0, import_jsx_runtime8.jsx)(TableText, { children }) : children, (0, import_jsx_runtime8.jsx)("span", { className: css(table_default.tableColumnHelpAction), children: variant === "tooltip" ? (0, import_jsx_runtime8.jsx)(Tooltip, Object.assign({ content: info2 }, tooltipProps, { children: (0, import_jsx_runtime8.jsx)(Button, { variant: "plain", hasNoPadding: true, "aria-label": ariaLabel || typeof info2 === "string" && info2 || "More info", icon: (0, import_jsx_runtime8.jsx)(help_icon_default, {}) }) })) : (0, import_jsx_runtime8.jsx)(Popover, Object.assign({ bodyContent: info2 }, popoverProps, { children: (0, import_jsx_runtime8.jsx)(Button, { variant: "plain", hasNoPadding: true, "aria-label": ariaLabel || typeof info2 === "string" && info2 || "More info", icon: (0, import_jsx_runtime8.jsx)(help_icon_default, {}) }) })) })] });
HeaderCellInfoWrapper.displayName = "HeaderCellInfoWrapper";

// node_modules/@patternfly/react-table/dist/esm/components/Table/RowWrapper.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());

// node_modules/@patternfly/react-table/dist/esm/components/Table/Tr.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var import_react11 = __toESM(require_react());

// node_modules/@patternfly/react-table/dist/esm/components/Table/Table.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var import_react10 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Table/table-grid.mjs
import "C:/Users/guillaumehouthoofd/Documents/Benoit/Epreuve_intégrée/ClubManager/front-end/node_modules/@patternfly/react-styles/css/components/Table/table-grid.css";
var table_grid_default = {
  "button": "pf-v6-c-button",
  "modifiers": {
    "grid": "pf-m-grid",
    "expandable": "pf-m-expandable",
    "expanded": "pf-m-expanded",
    "selected": "pf-m-selected",
    "compact": "pf-m-compact",
    "noPadding": "pf-m-no-padding",
    "hoverable": "pf-m-hoverable",
    "nowrap": "pf-m-nowrap",
    "fitContent": "pf-m-fit-content",
    "truncate": "pf-m-truncate",
    "gridMd": "pf-m-grid-md",
    "gridLg": "pf-m-grid-lg",
    "gridXl": "pf-m-grid-xl",
    "grid_2xl": "pf-m-grid-2xl"
  },
  "table": "pf-v6-c-table",
  "tableAction": "pf-v6-c-table__action",
  "tableButton": "pf-v6-c-table__button",
  "tableCheck": "pf-v6-c-table__check",
  "tableCompoundExpansionToggle": "pf-v6-c-table__compound-expansion-toggle",
  "tableExpandableRow": "pf-v6-c-table__expandable-row",
  "tableExpandableRowContent": "pf-v6-c-table__expandable-row-content",
  "tableFavorite": "pf-v6-c-table__favorite",
  "tableIcon": "pf-v6-c-table__icon",
  "tableInlineEditAction": "pf-v6-c-table__inline-edit-action",
  "tableTbody": "pf-v6-c-table__tbody",
  "tableTd": "pf-v6-c-table__td",
  "tableText": "pf-v6-c-table__text",
  "tableTh": "pf-v6-c-table__th",
  "tableThead": "pf-v6-c-table__thead",
  "tableToggle": "pf-v6-c-table__toggle",
  "tableToggleIcon": "pf-v6-c-table__toggle-icon",
  "tableTr": "pf-v6-c-table__tr"
};

// node_modules/@patternfly/react-styles/css/components/Table/table-tree-view.mjs
import "C:/Users/guillaumehouthoofd/Documents/Benoit/Epreuve_intégrée/ClubManager/front-end/node_modules/@patternfly/react-styles/css/components/Table/table-tree-view.css";
var table_tree_view_default = {
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "treeView": "pf-m-tree-view",
    "noInset": "pf-m-no-inset",
    "treeViewGrid": "pf-m-tree-view-grid",
    "borderRight": "pf-m-border-right",
    "treeViewDetailsExpanded": "pf-m-tree-view-details-expanded",
    "treeViewGridMd": "pf-m-tree-view-grid-md",
    "treeViewGridLg": "pf-m-tree-view-grid-lg",
    "treeViewGridXl": "pf-m-tree-view-grid-xl",
    "treeViewGrid_2xl": "pf-m-tree-view-grid-2xl"
  },
  "table": "pf-v6-c-table",
  "tableAction": "pf-v6-c-table__action",
  "tableCheck": "pf-v6-c-table__check",
  "tableTbody": "pf-v6-c-table__tbody",
  "tableTd": "pf-v6-c-table__td",
  "tableTh": "pf-v6-c-table__th",
  "tableThead": "pf-v6-c-table__thead",
  "tableToggle": "pf-v6-c-table__toggle",
  "tableToggleIcon": "pf-v6-c-table__toggle-icon",
  "tableTr": "pf-v6-c-table__tr",
  "tableTreeViewDetailsToggle": "pf-v6-c-table__tree-view-details-toggle",
  "tableTreeViewIcon": "pf-v6-c-table__tree-view-icon",
  "tableTreeViewMain": "pf-v6-c-table__tree-view-main",
  "tableTreeViewText": "pf-v6-c-table__tree-view-text",
  "tableTreeViewTitleCell": "pf-v6-c-table__tree-view-title-cell"
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/selectable.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-table/dist/esm/components/Table/SelectColumn.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());
var RowSelectVariant;
(function(RowSelectVariant2) {
  RowSelectVariant2["radio"] = "radio";
  RowSelectVariant2["checkbox"] = "checkbox";
})(RowSelectVariant || (RowSelectVariant = {}));
var SelectColumn = (_a) => {
  var {
    children = null,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className,
    onSelect = null,
    selectVariant,
    tooltip,
    tooltipProps
  } = _a, props = __rest(_a, ["children", "className", "onSelect", "selectVariant", "tooltip", "tooltipProps"]);
  const inputRef = (0, import_react7.createRef)();
  const content = (0, import_jsx_runtime9.jsxs)(import_react7.Fragment, { children: [(0, import_jsx_runtime9.jsx)("label", { children: (0, import_jsx_runtime9.jsx)("input", Object.assign({}, props, { ref: inputRef, type: selectVariant, onChange: onSelect })) }), children] });
  return tooltip ? (0, import_jsx_runtime9.jsx)(Tooltip, Object.assign({ triggerRef: inputRef, content: tooltip }, tooltipProps, { children: content })) : content;
};
SelectColumn.displayName = "SelectColumn";

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/selectable.js
var selectable = (label, { rowIndex, columnIndex, rowData, column, property, tooltip }) => {
  const { extraParams: { onSelect, selectVariant, allRowsSelected, isHeaderSelectDisabled } } = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property
  };
  if (rowData && rowData.hasOwnProperty("parent") && !rowData.showSelect && !rowData.fullWidth) {
    return {
      component: "td",
      isVisible: true
    };
  }
  const rowId = rowIndex !== void 0 ? rowIndex : -1;
  function selectClick(event) {
    const selected = rowIndex === void 0 ? event.currentTarget.checked : rowData && !rowData.selected;
    onSelect && onSelect(event, selected, rowId, rowData, extraData);
  }
  const customProps = Object.assign(Object.assign(Object.assign({}, rowId !== -1 ? {
    checked: rowData && !!rowData.selected,
    "aria-label": `Select row ${rowIndex}`
  } : {
    checked: allRowsSelected,
    "aria-label": "Select all rows"
  }), rowData && (rowData.disableCheckbox || rowData.disableSelection) && {
    disabled: true,
    className: check_default.checkInput
  }), !rowData && isHeaderSelectDisabled && { disabled: true });
  let selectName = "check-all";
  if (rowId !== -1 && selectVariant === RowSelectVariant.checkbox) {
    selectName = `checkrow${rowIndex}`;
  } else if (rowId !== -1) {
    selectName = "radioGroup";
  }
  return {
    className: css(table_default.tableCheck),
    component: rowId !== -1 ? "td" : "th",
    isVisible: !rowData || !rowData.fullWidth,
    children: (0, import_jsx_runtime10.jsx)(SelectColumn, Object.assign({}, customProps, { selectVariant, onSelect: selectClick, name: selectName, tooltip, children: label }))
  };
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/sortable.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-table/dist/esm/components/Table/SortColumn.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());
var SortByDirection;
(function(SortByDirection2) {
  SortByDirection2["asc"] = "asc";
  SortByDirection2["desc"] = "desc";
})(SortByDirection || (SortByDirection = {}));
var SortColumn = (_a) => {
  var { children = null, className = "", isSortedBy = false, onSort = null, sortDirection = "", type = "button", tooltip, tooltipProps, tooltipHasDefaultBehavior, favoriteButtonProps } = _a, props = __rest(_a, ["children", "className", "isSortedBy", "onSort", "sortDirection", "type", "tooltip", "tooltipProps", "tooltipHasDefaultBehavior", "favoriteButtonProps"]);
  let SortedByIcon;
  const [focused, setFocused] = (0, import_react8.useState)(false);
  if (isSortedBy) {
    SortedByIcon = sortDirection === SortByDirection.asc ? long_arrow_alt_up_icon_default : long_arrow_alt_down_icon_default;
  } else {
    SortedByIcon = arrows_alt_v_icon_default;
  }
  if (favoriteButtonProps) {
    return (0, import_jsx_runtime11.jsxs)(ActionList, { isIconList: true, children: [(0, import_jsx_runtime11.jsx)(ActionListItem, { children: (0, import_jsx_runtime11.jsx)(Button, Object.assign({ variant: "plain", icon: (0, import_jsx_runtime11.jsx)(star_icon_default, {}) }, favoriteButtonProps)) }), (0, import_jsx_runtime11.jsx)(ActionListItem, { children: (0, import_jsx_runtime11.jsx)(Button, Object.assign({ variant: "plain", icon: (0, import_jsx_runtime11.jsx)("span", { className: css(table_default.tableSortIndicator), children: (0, import_jsx_runtime11.jsx)(SortedByIcon, {}) }), onClick: (event) => onSort && onSort(event) }, props)) })] });
  }
  return (0, import_jsx_runtime11.jsx)("button", Object.assign({}, props, { type, className: css(className, table_default.tableButton), onClick: (event) => onSort && onSort(event), onFocus: () => setFocused(true), onBlur: () => setFocused(false), children: (0, import_jsx_runtime11.jsxs)("div", { className: css(className, table_default.tableButtonContent), children: [(0, import_jsx_runtime11.jsx)(TableText, { tooltip, tooltipProps, tooltipHasDefaultBehavior, focused, children }), (0, import_jsx_runtime11.jsx)("span", { className: css(table_default.tableSortIndicator), children: (0, import_jsx_runtime11.jsx)(SortedByIcon, {}) })] }) }));
};
SortColumn.displayName = "SortColumn";

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/sortable.js
var sortableFavorites = (sort) => () => {
  var _a;
  return sortable((0, import_jsx_runtime12.jsx)(star_icon_default, {}), {
    columnIndex: sort.columnIndex,
    className: table_default.tableFavorite,
    ariaLabel: (_a = sort.ariaLabel) !== null && _a !== void 0 ? _a : "Sort favorites",
    column: {
      extraParams: {
        sortBy: sort.sortBy,
        onSort: sort.onSort,
        favoriteButtonProps: sort.favoriteButtonProps
      }
    },
    tooltip: sort.tooltip,
    tooltipProps: sort.tooltipProps,
    tooltipHasDefaultBehavior: true
  });
};
var sortable = (label, { columnIndex, column, property, className, ariaLabel, tooltip, tooltipProps, tooltipHasDefaultBehavior }) => {
  const { extraParams: { sortBy, onSort, favoriteButtonProps } } = column;
  const extraData = {
    columnIndex,
    column,
    property
  };
  const isSortedBy = sortBy && columnIndex === sortBy.index;
  function sortClicked(event) {
    let reversedDirection;
    if (!isSortedBy) {
      reversedDirection = sortBy.defaultDirection ? sortBy.defaultDirection : SortByDirection.asc;
    } else {
      reversedDirection = sortBy.direction === SortByDirection.asc ? SortByDirection.desc : SortByDirection.asc;
    }
    onSort && onSort(event, columnIndex, reversedDirection, extraData);
  }
  return Object.assign(Object.assign({ className: css(table_default.tableSort, isSortedBy && table_default.modifiers.selected, className) }, isSortedBy && { "aria-sort": `${sortBy.direction}ending` }), { children: (0, import_jsx_runtime12.jsx)(SortColumn, { isSortedBy, sortDirection: isSortedBy ? sortBy.direction : "", onSort: sortClicked, "aria-label": ariaLabel, tooltip, tooltipProps, tooltipHasDefaultBehavior, favoriteButtonProps, children: label }) });
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/cellActions.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var resolveOrDefault = (resolver, defaultValue, rowData, extraData) => typeof resolver === "function" ? resolver(rowData, extraData) : defaultValue;
var cellActions = (actions, actionResolver, areActionsDisabled) => (label, { rowData, column, rowIndex, columnIndex, column: { extraParams: { actionsToggle, actionsPopperProps } }, property }) => {
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property
  };
  const resolvedActions = resolveOrDefault(actionResolver, actions, rowData, extraData);
  const resolvedIsDisabled = resolveOrDefault(areActionsDisabled, rowData && rowData.disableActions, rowData, extraData);
  const renderProps = resolvedActions && resolvedActions.length > 0 ? {
    children: (0, import_jsx_runtime13.jsx)(ActionsColumn, { items: resolvedActions, isDisabled: resolvedIsDisabled, rowData, extraData, actionsToggle, popperProps: actionsPopperProps, children: label })
  } : {};
  return Object.assign({ className: css(table_default.tableAction), style: { paddingRight: 0 }, isVisible: true }, renderProps);
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/utils.js
var hasCompoundParentsExpanded = (parentId2, compoundParent, rows) => {
  for (const i of rows) {
    if (rows[parentId2].hasOwnProperty("parent")) {
      parentId2 = rows[parentId2].parent;
    } else {
      return rows[parentId2].cells[compoundParent].props.isOpen;
    }
  }
  return false;
};
var hasParentsExpanded = (parentId2, rows) => {
  for (const i of rows) {
    if (rows[parentId2].hasOwnProperty("parent")) {
      parentId2 = rows[parentId2].parent;
    } else {
      return rows[parentId2].isOpen;
    }
  }
  return false;
};
var isRowExpanded = (row, rows) => {
  if (row.parent !== void 0) {
    if (row.hasOwnProperty("compoundParent")) {
      return hasCompoundParentsExpanded(row.parent, row.compoundParent, rows);
    }
    return hasParentsExpanded(row.parent, rows) && rows[row.parent].isOpen;
  }
  return void 0;
};
var getErrorTextByValidator = (validatorName, validators) => {
  const result = validators.filter((validator) => validator.name === validatorName);
  return result[0].errorText;
};
var cancelCellEdits = (row) => {
  row.cells.forEach((cell) => {
    delete cell.props.errorText;
    delete cell.props.editableValue;
    cell.props.isValid = true;
    if (cell.props.selected) {
      cell.props.selected = cell.props.value;
    }
  });
  row.isEditable = !row.isEditable;
  row.isValid = true;
  return row;
};
var validateCellEdits = (row, type, validationErrors, missingPropErrorTxt = "Validation requires unique name property for row cells") => {
  row.isValid = Object.keys(validationErrors).length ? false : true;
  row.cells.forEach((cell) => {
    delete cell.props.errorText;
    const hasValue = cell.props.value !== void 0 && cell.props.value !== null;
    const hasEditableValue = cell.props.editableValue !== void 0 && cell.props.editableValue !== null;
    if (cell.props && hasValue && hasEditableValue) {
      if (type === "save") {
        const errorMsg = Object.keys(validationErrors).filter((validatorName) => validationErrors[validatorName].includes(cell.props.name)).map((validatorName) => getErrorTextByValidator(validatorName, row.rowEditValidationRules));
        if (errorMsg.length) {
          cell.props.errorText = cell.props.name ? errorMsg.join(", ") : missingPropErrorTxt;
          if (cell.props.name === void 0) {
            console.warn("Row edit validation reporting requires cell definitions to have a unique name property.");
          }
        } else {
          delete cell.props.errorText;
          cell.props.isValid = true;
        }
      }
    }
  });
  return row;
};
var applyCellEdits = (row, type) => {
  row.cells.forEach((cell) => {
    delete cell.props.errorText;
    const hasValue = cell.props.value !== void 0 && cell.props.value !== null;
    const hasEditableValue = cell.props.editableValue !== void 0 && cell.props.editableValue !== null;
    if (hasValue && !hasEditableValue) {
      cell.props.editableValue = cell.props.value;
    }
    if (cell.props && hasValue && hasEditableValue) {
      if (type === "save") {
        cell.props.value = cell.props.editableValue;
        cell.props.isValid = true;
        delete cell.props.errorText;
      }
      delete cell.props.editableValue;
    }
  });
  row.isEditable = !row.isEditable;
  row.isValid = true;
  return row;
};
var camelize = (s) => s.toUpperCase().replace("-", "").replace("_", "");
var toCamel = (s) => s.replace(/([-_][a-z])/gi, camelize);
function capitalize(input) {
  return input[0].toUpperCase() + input.substring(1);
}

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/cellWidth.js
var cellWidth = (width) => () => ({
  className: css(table_default.modifiers[typeof width === "number" ? `width_${width}` : `width${capitalize(width)}`])
});

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/editable.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-table/dist/esm/components/Table/EditColumn.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());
var EditColumn = (_a) => {
  var {
    onClick = null,
    /* eslint-disable @typescript-eslint/no-unused-vars */
    className = "",
    editing,
    valid,
    /* eslint-enable @typescript-eslint/no-unused-vars */
    saveAriaLabel,
    cancelAriaLabel,
    editAriaLabel
  } = _a, props = __rest(_a, ["onClick", "className", "editing", "valid", "saveAriaLabel", "cancelAriaLabel", "editAriaLabel"]);
  return (0, import_jsx_runtime14.jsxs)(import_react9.Fragment, { children: [(0, import_jsx_runtime14.jsxs)("div", { className: css(inline_edit_default.inlineEditGroup, inline_edit_default.modifiers.iconGroup, "pf-m-action-group"), children: [(0, import_jsx_runtime14.jsx)("div", { className: css(inline_edit_default.inlineEditAction), children: (0, import_jsx_runtime14.jsx)(Button, Object.assign({ "aria-label": saveAriaLabel }, props, { onClick: (e) => onClick(e, "save"), variant: "plain", icon: (0, import_jsx_runtime14.jsx)(check_icon_default, {}) })) }), (0, import_jsx_runtime14.jsx)("div", { className: css(inline_edit_default.inlineEditAction), children: (0, import_jsx_runtime14.jsx)(Button, Object.assign({ "aria-label": cancelAriaLabel }, props, { onClick: (e) => onClick(e, "cancel"), variant: "plain", icon: (0, import_jsx_runtime14.jsx)(times_icon_default, {}) })) })] }), (0, import_jsx_runtime14.jsx)("div", { className: css(inline_edit_default.inlineEditAction, inline_edit_default.modifiers.enableEditable), children: (0, import_jsx_runtime14.jsx)(Button, Object.assign({ "aria-label": editAriaLabel }, props, { onClick: (e) => onClick(e, "edit"), variant: "plain", icon: (0, import_jsx_runtime14.jsx)(pencil_alt_icon_default, {}) })) })] });
};
EditColumn.displayName = "EditColumn";

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/editable.js
var editable = (label, { rowIndex, rowData, column }) => {
  const { extraParams: { onRowEdit } } = column;
  const toggleEditMode = (event, type) => {
    let validationErrors = {};
    if (type === "save") {
      validationErrors = rowData.rowEditValidationRules && rowData.rowEditValidationRules.reduce((acc, rule) => {
        const invalidCells = rowData.cells.filter((cellData) => {
          const testValue = cellData.props.editableValue === "" ? "" : cellData.props.editableValue || cellData.props.value;
          let failedValidation = false;
          if (Array.isArray(testValue) && testValue.length) {
            failedValidation = testValue.reduce((hasInvalidSelection, el) => {
              if (hasInvalidSelection === true) {
                return true;
              }
              return !rule.validator(el);
            }, failedValidation);
          } else if (Array.isArray(testValue) && !testValue.length) {
            failedValidation = !rule.validator("");
          } else {
            failedValidation = !rule.validator(testValue);
          }
          if (failedValidation) {
            cellData.props.isValid = false;
          }
          return failedValidation;
        });
        if (invalidCells.length) {
          acc[rule.name] = invalidCells.map((cell) => cell.props.name);
        }
        return acc;
      }, {});
    }
    onRowEdit(event, type, rowData && rowData.isEditable, rowIndex, validationErrors);
  };
  function getAriaLabelTxt(identifier, actionType) {
    let result;
    switch (actionType) {
      case "cancel":
        result = `Cancel row edits for row ${identifier}`;
        break;
      case "save":
        result = `Save row edits for row ${identifier}`;
        break;
      default:
        result = `Place row ${identifier} in edit mode`;
    }
    return result;
  }
  return {
    className: table_default.tableInlineEditAction,
    component: "td",
    isVisible: true,
    children: (0, import_jsx_runtime15.jsx)(EditColumn, { saveAriaLabel: rowData && rowData.rowSaveBtnAriaLabel && rowData.rowSaveBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, "save"), cancelAriaLabel: rowData && rowData.rowCancelBtnAriaLabel && rowData.rowCancelBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, "cancel"), editAriaLabel: rowData && rowData.rowEditBtnAriaLabel && rowData.rowEditBtnAriaLabel(rowIndex) || getAriaLabelTxt(rowIndex, "edit"), valid: rowData && rowData.isValid, editing: rowData && rowData.isEditable, onClick: toggleEditMode })
  };
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/wrappable.js
var breakWord = () => ({
  className: table_default.modifiers.breakWord
});
var fitContent = () => ({
  className: table_default.modifiers.fitContent
});
var nowrap = () => ({
  className: table_default.modifiers.nowrap
});
var truncate = () => ({
  className: table_default.modifiers.truncate
});
var wrappable = () => ({
  className: table_default.modifiers.wrap
});

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/textCenter.js
var textCenter = () => ({ textCenter: true });

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/collapsible.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var collapsible = (value, { rowIndex, columnIndex, rowData, column, property }) => {
  const { extraParams: { onCollapse, rowLabeledBy = "simple-node", expandId = "expand-toggle", allRowsExpanded, collapseAllAriaLabel } } = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property
  };
  const rowId = rowIndex !== void 0 ? rowIndex : -1;
  const customProps = Object.assign({}, rowId !== -1 ? {
    isOpen: rowData === null || rowData === void 0 ? void 0 : rowData.isOpen,
    "aria-labelledby": `${rowLabeledBy}${rowId} ${expandId}${rowId}`
  } : {
    isOpen: allRowsExpanded,
    "aria-label": collapseAllAriaLabel || "Expand all rows"
  });
  function onToggle(event) {
    const open = rowData ? !rowData.isOpen : !allRowsExpanded;
    onCollapse && onCollapse(event, rowIndex, open, rowData, extraData);
  }
  return {
    className: ((rowData === null || rowData === void 0 ? void 0 : rowData.isOpen) !== void 0 || rowId === -1) && css(table_default.tableToggle),
    isVisible: !(rowData === null || rowData === void 0 ? void 0 : rowData.fullWidth),
    children: (0, import_jsx_runtime16.jsx)(CollapseColumn, Object.assign({ "aria-labelledby": `${rowLabeledBy}${rowId} ${expandId}${rowId}`, onToggle, id: expandId + rowId }, customProps, { children: value }))
  };
};
var expandable = (value, { rowData }) => rowData && rowData.hasOwnProperty("parent") ? (0, import_jsx_runtime16.jsx)(ExpandableRowContent, { children: value }) : value;
var expandedRow = (colSpan, additionalColSpan = 0) => {
  const expandedRowFormatter = (value, { columnIndex, rowIndex, rowData, column: { extraParams: { contentId = "expanded-content" } } }) => value && rowData.hasOwnProperty("parent") && {
    colSpan: !rowData.cells || rowData.cells.length === 1 ? colSpan + (rowData.fullWidth ? additionalColSpan + 1 : 0) : 1,
    id: contentId + rowIndex + (columnIndex ? "-" + columnIndex : ""),
    className: rowData.noPadding && css(table_default.modifiers.noPadding)
  };
  return expandedRowFormatter;
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/compoundExpand.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var compoundExpand = (value, { rowIndex, columnIndex, rowData, column, property }) => {
  if (!value) {
    return null;
  }
  const { title, props } = value;
  const { extraParams: { onExpand, expandId = "expand-toggle" } } = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property
  };
  function onToggle(event) {
    onExpand && onExpand(event, rowIndex, columnIndex, props.isOpen, rowData, extraData);
  }
  return {
    className: css(table_default.tableCompoundExpansionToggle, props.isOpen && table_default.modifiers.expanded),
    children: props.isOpen !== void 0 && (0, import_jsx_runtime17.jsx)("button", { type: "button", className: css(table_default.tableButton), onClick: onToggle, "aria-expanded": props.isOpen, "aria-controls": props.ariaControls, id: `${expandId}-${rowIndex}-${columnIndex}`, children: (0, import_jsx_runtime17.jsx)(TableText, { children: title }) })
  };
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/headerCol.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var headerCol = (id = "simple-node") => {
  const headerColObj = (value, { rowIndex } = {}) => {
    const result = typeof value === "object" ? value.title : value;
    return {
      component: "th",
      children: (0, import_jsx_runtime18.jsx)("div", { id: `${id}${rowIndex}`, children: result })
    };
  };
  return headerColObj;
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/classNames.js
var visibilityModifiers = [
  "hidden",
  "hiddenOnSm",
  "hiddenOnMd",
  "hiddenOnLg",
  "hiddenOnXl",
  "hiddenOn_2xl",
  "visibleOnSm",
  "visibleOnMd",
  "visibleOnLg",
  "visibleOnXl",
  "visibleOn_2xl"
];
var Visibility = visibilityModifiers.filter((key) => table_default.modifiers[key]).reduce((acc, curr) => {
  const key2 = curr.replace("_2xl", "2Xl");
  acc[key2] = table_default.modifiers[curr];
  return acc;
}, {});
var classNames = (...classes) => () => ({
  className: css(...classes)
});

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/info.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var info = ({ tooltip, tooltipProps, popover, popoverProps, className, ariaLabel }) => {
  const infoObj = (value) => ({
    className: table_default.modifiers.help,
    children: tooltip ? (0, import_jsx_runtime19.jsx)(HeaderCellInfoWrapper, { variant: "tooltip", info: tooltip, tooltipProps, ariaLabel, className, children: value }) : (0, import_jsx_runtime19.jsx)(HeaderCellInfoWrapper, { variant: "popover", info: popover, popoverProps, ariaLabel, className, children: value })
  });
  return infoObj;
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/favoritable.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-table/dist/esm/components/Table/FavoritesCell.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var FavoritesCell = (_a) => {
  var { className = "", onFavorite, isFavorited, rowIndex } = _a, props = __rest(_a, ["className", "onFavorite", "isFavorited", "rowIndex"]);
  const ariaProps = rowIndex === void 0 ? {} : {
    id: `favorites-button-${rowIndex}`,
    "aria-labelledby": `favorites-button-${rowIndex}`
  };
  return (0, import_jsx_runtime20.jsx)(Button, Object.assign({ variant: "plain", className, type: "button", "aria-label": isFavorited ? "Starred" : "Not starred", onClick: onFavorite }, ariaProps, props, { icon: (0, import_jsx_runtime20.jsx)(star_icon_default, {}) }));
};
FavoritesCell.displayName = "FavoritesCell";

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/favoritable.js
var favoritable = (value, { rowIndex, columnIndex, rowData, column, property }) => {
  const { extraParams: { onFavorite } } = column;
  const extraData = {
    rowIndex,
    columnIndex,
    column,
    property
  };
  if (rowData && rowData.hasOwnProperty("parent") && !rowData.fullWidth) {
    return {
      component: "td",
      isVisible: true
    };
  }
  function favoritesClick(event) {
    onFavorite && onFavorite(event, rowData && !rowData.favorited, rowIndex, rowData, extraData);
  }
  const additionalProps = rowData.favoritesProps || {};
  return {
    className: css(table_default.tableFavorite, rowData && rowData.favorited && table_default.modifiers.favorited),
    isVisible: !rowData || !rowData.fullWidth,
    children: (0, import_jsx_runtime21.jsx)(FavoritesCell, Object.assign({ rowIndex, onFavorite: favoritesClick, isFavorited: rowData && rowData.favorited }, additionalProps))
  };
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/treeRow.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var treeRow = (onCollapse, onCheckChange, onToggleRowDetails) => (value, { rowIndex, rowData }) => {
  const { isExpanded, isDetailsExpanded, "aria-level": level, "aria-setsize": setsize, toggleAriaLabel, checkAriaLabel, showDetailsAriaLabel, isChecked, checkboxId, icon } = rowData.props;
  const content = value.title || value;
  const text = (0, import_jsx_runtime22.jsxs)("div", { className: css(table_tree_view_default.tableTreeViewText), children: [icon && (0, import_jsx_runtime22.jsx)("span", { className: css(table_tree_view_default.tableTreeViewIcon), children: icon }, "tree-view-text-icon"), (0, import_jsx_runtime22.jsx)("span", { className: table_default.tableText, children: content }, "table-text")] }, "tree-view-text");
  const onChange = (isChecked2, event) => {
    onCheckChange(event, isChecked2, rowIndex, content, rowData);
  };
  return {
    component: "th",
    className: table_tree_view_default.tableTreeViewTitleCell,
    children: level !== void 0 ? (0, import_jsx_runtime22.jsxs)("div", { className: css(table_tree_view_default.tableTreeViewMain), children: [setsize > 0 && (0, import_jsx_runtime22.jsx)("span", { className: css(table_tree_view_default.tableToggle), children: (0, import_jsx_runtime22.jsx)(Button, { variant: "plain", onClick: (event) => onCollapse && onCollapse(event, rowIndex, content, rowData), className: css(isExpanded && table_default.modifiers.expanded), "aria-expanded": isExpanded, "aria-label": toggleAriaLabel || `${isExpanded ? "Collapse" : "Expand"} row ${rowIndex}`, icon: (0, import_jsx_runtime22.jsx)("div", { className: css(table_tree_view_default.tableToggleIcon), children: (0, import_jsx_runtime22.jsx)(angle_down_icon_default, {}) }) }) }, "table-toggle"), !!onCheckChange && (0, import_jsx_runtime22.jsx)("span", { className: css(table_tree_view_default.tableCheck), children: (0, import_jsx_runtime22.jsx)("label", { htmlFor: checkboxId || `checkbox_${rowIndex}`, children: (0, import_jsx_runtime22.jsx)(Checkbox, { id: checkboxId || `checkbox_${rowIndex}`, "aria-label": checkAriaLabel || `Row ${rowIndex} checkbox`, isChecked, onChange: (event, checked) => onChange(checked, event) }) }) }, "table-check"), text, !!onToggleRowDetails && (0, import_jsx_runtime22.jsx)("span", { className: css(table_tree_view_default.tableTreeViewDetailsToggle), children: (0, import_jsx_runtime22.jsx)(Button, { variant: "plain", "aria-expanded": isDetailsExpanded, "aria-label": showDetailsAriaLabel || "Show row details", onClick: (event) => onToggleRowDetails && onToggleRowDetails(event, rowIndex, content, rowData), icon: (0, import_jsx_runtime22.jsx)("span", { className: `${table_default.table}__details-toggle-icon`, children: (0, import_jsx_runtime22.jsx)(ellipsis_h_icon_default, {}) }) }) }, "view-details-toggle")] }) : text
  };
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/transformers.js
var emptyTD = () => ({
  component: "td"
});
var scopeColTransformer = () => ({
  scope: "col"
});
var emptyCol = (label) => Object.assign({}, label ? {} : { scope: "" });
var parentId = (_value, { rowData }) => ({
  parentId: rowData.parent
});
var mapProps = (_label, { property, rowData }) => Object.assign({}, rowData[property] && rowData[property].props);

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/formatters.js
var defaultTitle = (data) => data && data.hasOwnProperty("title") ? data.title : data;

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/headerUtils.js
var generateHeader = ({ transforms: origTransforms, formatters: origFormatters, columnTransforms, header }, title) => Object.assign(Object.assign({}, header), { label: title, transforms: [
  scopeColTransformer,
  emptyCol,
  ...origTransforms || [],
  ...columnTransforms || [],
  ...header && header.hasOwnProperty("transforms") ? header.transforms : []
], formatters: [...origFormatters || [], ...header && header.hasOwnProperty("formatters") ? header.formatters : []] });
var generateCell = ({ cellFormatters, cellTransforms, columnTransforms, cell }, extra) => Object.assign(Object.assign({}, cell), { transforms: [
  ...cellTransforms || [],
  ...columnTransforms || [],
  ...cell && cell.hasOwnProperty("transforms") ? cell.transforms : [],
  mapProps
  // This transform should be applied last so that props that are manually defined at the cell level will override all other transforms.
], formatters: [
  defaultTitle,
  ...cellFormatters || [],
  ...cell && cell.hasOwnProperty("formatters") ? cell.formatters : []
] });
var mapHeader = (column, extra, key, ...props) => {
  const title = column.hasOwnProperty("title") ? column.title : column;
  let dataLabel = `column-${key}`;
  if (column.hasOwnProperty("dataLabel")) {
    dataLabel = column.dataLabel;
  } else if (typeof title === "string") {
    dataLabel = title;
  }
  return {
    property: typeof title === "string" && title.toLowerCase().trim().replace(/\s/g, "-") || `column-${key}`,
    extraParams: extra,
    data: column.data,
    header: generateHeader(column, title),
    cell: generateCell(column, extra),
    props: Object.assign(Object.assign({ "data-label": dataLabel, "data-key": key }, column.hasOwnProperty("props") ? column.props : {}), props)
  };
};
var selectableTransforms = ({ onSelect, canSelectAll }) => [
  ...onSelect ? [
    {
      title: "",
      transforms: canSelectAll && [selectable] || null,
      cellTransforms: [selectable]
    }
  ] : []
];
var favoritesTransforms = ({ onFavorite, onSort, sortBy, canSortFavorites, firstUserColumnIndex }) => [
  ...onFavorite ? [
    {
      title: "",
      transforms: onSort && canSortFavorites ? [
        scopeColTransformer,
        sortableFavorites({
          onSort,
          // favorites should be just before the first user-defined column
          columnIndex: firstUserColumnIndex - 1,
          sortBy
        })
      ] : [emptyTD],
      cellTransforms: [favoritable]
    }
  ] : []
];
var actionsTransforms = ({ actions, actionResolver, areActionsDisabled }) => [
  ...actionResolver || actions ? [
    {
      title: "",
      transforms: [emptyTD],
      cellTransforms: [cellActions(actions, actionResolver, areActionsDisabled)]
    }
  ] : []
];
var collapsibleTransforms = (header, { onCollapse, canCollapseAll, firstUserColumnIndex }) => [
  ...onCollapse ? [
    {
      title: "",
      transforms: canCollapseAll && [collapsible] || null,
      cellTransforms: [collapsible, expandedRow(header.length, firstUserColumnIndex)]
    }
  ] : []
];
var addAdditionalCellTranforms = (cell, additional) => Object.assign(Object.assign({}, cell.hasOwnProperty("title") ? cell : { title: cell }), { cellTransforms: [...cell.hasOwnProperty("cellTransforms") ? cell.cellTransforms : [], additional] });
var expandContent = (header, extra) => {
  if (!extra.onCollapse && !extra.onExpand) {
    return header;
  }
  return header.map((cell) => {
    const parentIdCell = addAdditionalCellTranforms(cell, parentId);
    return addAdditionalCellTranforms(parentIdCell, expandedRow(header.length));
  });
};
var mapOpenedRows = (rows, children) => rows.reduce((acc, curr, key) => {
  if (curr.hasOwnProperty("parent")) {
    const parent = acc.length > 0 && acc[acc.length - 1];
    if (parent) {
      acc[acc.length - 1].rows = [...acc[acc.length - 1].rows, children[key]];
      if (curr.hasOwnProperty("compoundParent")) {
        acc[acc.length - 1].isOpen = acc[acc.length - 1].rows.some((oneRow) => oneRow.props.rowData.cells.some((oneCell) => oneCell.props && oneCell.props.isOpen));
      }
    }
  } else {
    acc = [...acc, Object.assign(Object.assign({}, curr), { rows: [children[key]] })];
  }
  return acc;
}, []);
var rowEditTransforms = ({ onRowEdit }) => [
  ...onRowEdit ? [
    {
      title: "",
      cellTransforms: [editable]
    }
  ] : []
];
var calculateColumns = (headerRows, extra) => headerRows && [
  ...collapsibleTransforms(headerRows, extra),
  ...selectableTransforms(extra),
  ...favoritesTransforms(extra),
  ...expandContent(headerRows, extra),
  ...rowEditTransforms(extra),
  ...actionsTransforms(extra)
].map((oneCol, key) => Object.assign({}, mapHeader(oneCol, extra, key)));

// node_modules/@patternfly/react-table/dist/esm/components/Table/TableTypes.js
var TableGridBreakpoint;
(function(TableGridBreakpoint2) {
  TableGridBreakpoint2["none"] = "";
  TableGridBreakpoint2["grid"] = "grid";
  TableGridBreakpoint2["gridMd"] = "grid-md";
  TableGridBreakpoint2["gridLg"] = "grid-lg";
  TableGridBreakpoint2["gridXl"] = "grid-xl";
  TableGridBreakpoint2["grid2xl"] = "grid-2xl";
})(TableGridBreakpoint || (TableGridBreakpoint = {}));
var TableVariant;
(function(TableVariant2) {
  TableVariant2["compact"] = "compact";
})(TableVariant || (TableVariant = {}));

// node_modules/@patternfly/react-table/dist/esm/components/Table/Table.js
var TableContext = (0, import_react10.createContext)({
  registerSelectableRow: () => {
  }
});
var TableBase = (_a) => {
  var _b, _c;
  var {
    children,
    className,
    variant,
    borders = true,
    isStickyHeader = false,
    gridBreakPoint = TableGridBreakpoint.gridMd,
    "aria-label": ariaLabel,
    role = "grid",
    innerRef,
    ouiaId,
    ouiaSafe = true,
    isTreeTable = false,
    isNested = false,
    isStriped = false,
    isExpandable = false,
    hasNoInset = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    nestedHeaderColumnSpans,
    selectableRowCaptionText
  } = _a, props = __rest(_a, ["children", "className", "variant", "borders", "isStickyHeader", "gridBreakPoint", "aria-label", "role", "innerRef", "ouiaId", "ouiaSafe", "isTreeTable", "isNested", "isStriped", "isExpandable", "hasNoInset", "nestedHeaderColumnSpans", "selectableRowCaptionText"]);
  const ref = (0, import_react10.useRef)(null);
  const tableRef = innerRef || ref;
  const [hasSelectableRows, setHasSelectableRows] = (0, import_react10.useState)(false);
  const [tableCaption, setTableCaption] = (0, import_react10.useState)();
  (0, import_react10.useEffect)(() => {
    document.addEventListener("keydown", handleKeys);
    if (tableRef && tableRef.current && tableRef.current.classList.contains("pf-m-tree-view")) {
      const tbody = tableRef.current.querySelector("tbody");
      tbody && setTabIndex(Array.from(tbody.querySelectorAll("button, a, input")));
    }
    return function cleanup() {
      document.removeEventListener("keydown", handleKeys);
    };
  }, [tableRef, tableRef.current]);
  (0, import_react10.useEffect)(() => {
    if (selectableRowCaptionText) {
      setTableCaption((0, import_jsx_runtime23.jsxs)("caption", { children: [selectableRowCaptionText, (0, import_jsx_runtime23.jsx)("div", { className: "pf-v6-screen-reader", children: "This table has selectable rows. It can be navigated by row using tab, and each row can be selected using space or enter." })] }));
    } else {
      setTableCaption((0, import_jsx_runtime23.jsx)("caption", { className: "pf-v6-screen-reader", children: "This table has selectable rows. It can be navigated by row using tab, and each row can be selected using space or enter." }));
    }
  }, [selectableRowCaptionText]);
  const ouiaProps = useOUIAProps("Table", ouiaId, ouiaSafe);
  const grid = (_b = table_grid_default.modifiers) === null || _b === void 0 ? void 0 : _b[toCamel(gridBreakPoint || "").replace(/-?2xl/, "_2xl")];
  const breakPointPrefix = `treeView${gridBreakPoint.charAt(0).toUpperCase() + gridBreakPoint.slice(1)}`;
  const treeGrid = (_c = table_tree_view_default.modifiers) === null || _c === void 0 ? void 0 : _c[toCamel(breakPointPrefix || "").replace(/-?2xl/, "_2xl")];
  const handleKeys = (event) => {
    if (isNested || !(tableRef && tableRef.current && tableRef.current.classList.contains(table_tree_view_default.modifiers.treeView)) || // implements roving tab-index to tree tables only
    tableRef && tableRef.current !== event.target.closest(`.${table_default.table}:not(.pf-m-nested)`)) {
      return;
    }
    const activeElement = document.activeElement;
    const key = event.key;
    const rows = Array.from(tableRef.current.querySelectorAll("tbody tr")).filter((el) => !el.classList.contains("pf-m-disabled") && !el.hidden);
    if (key === KeyTypes.Space || key === KeyTypes.Enter) {
      activeElement.click();
      event.preventDefault();
    }
    const getFocusableElement = (element) => element.querySelectorAll("button:not(:disabled), input:not(:disabled), a:not(:disabled)")[0];
    handleArrows(event, rows, (element) => element === activeElement.closest("tr"), getFocusableElement, ["button", "input", "a"], void 0, false, true, false);
  };
  const registerSelectableRow = () => {
    !hasSelectableRows && setHasSelectableRows(true);
  };
  return (0, import_jsx_runtime23.jsx)(TableContext.Provider, { value: { registerSelectableRow }, children: (0, import_jsx_runtime23.jsxs)("table", Object.assign({ "aria-label": ariaLabel, role, className: css(className, table_default.table, isTreeTable ? treeGrid : grid, table_default.modifiers[variant], !borders && table_default.modifiers.noBorderRows, isStickyHeader && table_default.modifiers.stickyHeader, isTreeTable && table_tree_view_default.modifiers.treeView, isStriped && table_default.modifiers.striped, isExpandable && table_default.modifiers.expandable, hasNoInset && table_tree_view_default.modifiers.noInset, isNested && "pf-m-nested"), ref: tableRef }, isTreeTable && { role: "treegrid" }, ouiaProps, props, { children: [hasSelectableRows && tableCaption, children] })) });
};
var Table = (0, import_react10.forwardRef)((props, ref) => (0, import_jsx_runtime23.jsx)(TableBase, Object.assign({}, props, { innerRef: ref })));
Table.displayName = "Table";

// node_modules/@patternfly/react-table/dist/esm/components/Table/Tr.js
var TrBase = (_a) => {
  var { children, className, isExpanded, isEditable, isHidden = false, isClickable = false, isRowSelected = false, isStriped = false, isBorderRow = false, isControlRow = false, innerRef, ouiaId, ouiaSafe = true, resetOffset = false, onRowClick, isSelectable, "aria-label": passedAriaLabel } = _a, props = __rest(_a, ["children", "className", "isExpanded", "isEditable", "isHidden", "isClickable", "isRowSelected", "isStriped", "isBorderRow", "isControlRow", "innerRef", "ouiaId", "ouiaSafe", "resetOffset", "onRowClick", "isSelectable", "aria-label"]);
  const ouiaProps = useOUIAProps("TableRow", ouiaId, ouiaSafe);
  const [computedAriaLabel, setComputedAriaLabel] = (0, import_react11.useState)("");
  let onKeyDown = null;
  if (onRowClick) {
    onKeyDown = (e) => {
      if (e.key === "Enter" || e.key === " ") {
        onRowClick(e);
        e.preventDefault();
      }
    };
  }
  const rowIsHidden = isHidden || isExpanded !== void 0 && !isExpanded;
  const { registerSelectableRow } = (0, import_react11.useContext)(TableContext);
  (0, import_react11.useEffect)(() => {
    if (isSelectable && !rowIsHidden) {
      setComputedAriaLabel(`${isRowSelected ? "Row selected" : ""}`);
      registerSelectableRow();
    } else {
      setComputedAriaLabel(void 0);
    }
  }, [isRowSelected, isSelectable, registerSelectableRow, rowIsHidden]);
  const ariaLabel = passedAriaLabel || computedAriaLabel;
  return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: (0, import_jsx_runtime24.jsx)("tr", Object.assign({ className: css(table_default.tableTr, className, isExpanded !== void 0 && table_default.tableExpandableRow, isExpanded && table_default.modifiers.expanded, isEditable && inline_edit_default.modifiers.inlineEditable, isClickable && table_default.modifiers.clickable, isRowSelected && table_default.modifiers.selected, isStriped && table_default.modifiers.striped, isBorderRow && table_default.modifiers.borderRow, isControlRow && table_default.tableControlRow, resetOffset && table_default.modifiers.firstCellOffsetReset), hidden: rowIsHidden }, isClickable && { tabIndex: 0 }, { "aria-label": ariaLabel, ref: innerRef }, onRowClick && { onClick: onRowClick, onKeyDown }, ouiaProps, props, { children })) });
};
var Tr = (0, import_react11.forwardRef)((props, ref) => (0, import_jsx_runtime24.jsx)(TrBase, Object.assign({}, props, { innerRef: ref })));
Tr.displayName = "Tr";

// node_modules/@patternfly/react-table/dist/esm/components/Table/RowWrapper.js
var RowWrapper = class extends import_react12.Component {
  constructor(props) {
    super(props);
    this.handleScroll = (event) => {
      if (!this._unmounted) {
        this.props.onScroll(event);
      }
    };
    this.handleResize = (event) => {
      if (!this._unmounted) {
        this.props.onResize(event);
      }
    };
    if (props.onScroll) {
      this.handleScroll = debounce(this.handleScroll, 100);
    }
    if (props.onResize) {
      this.handleResize = debounce(this.handleResize, 100);
    }
  }
  componentDidMount() {
    this._unmounted = false;
    if (canUseDOM) {
      if (this.props.onScroll) {
        window.addEventListener("scroll", this.handleScroll);
      }
      if (this.props.onResize) {
        window.addEventListener("resize", this.handleResize);
      }
    }
  }
  componentWillUnmount() {
    this._unmounted = true;
    if (canUseDOM) {
      if (this.props.onScroll) {
        window.removeEventListener("scroll", this.handleScroll);
      }
      if (this.props.onResize) {
        window.removeEventListener("resize", this.handleResize);
      }
    }
  }
  render() {
    const _a = this.props, {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onScroll,
      onResize,
      row: { isExpanded, isEditable, isClickable, isRowSelected },
      rowProps,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      trRef,
      className,
      ouiaId
    } = _a, props = __rest(_a, ["onScroll", "onResize", "row", "rowProps", "trRef", "className", "ouiaId"]);
    return (0, import_jsx_runtime25.jsx)(Tr, Object.assign({}, props, { ref: trRef, isExpanded, isEditable, className, ouiaId, isClickable, isRowSelected }));
  }
};
RowWrapper.displayName = "RowWrapper";
RowWrapper.defaultProps = {
  className: "",
  row: {
    isOpen: void 0,
    isExpanded: void 0,
    isHeightAuto: void 0,
    isEditable: void 0
  },
  rowProps: null
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/TreeRowWrapper.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var TreeRowWrapper = (_a) => {
  var {
    className,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rowProps,
    row
  } = _a, props = __rest(_a, ["className", "rowProps", "row"]);
  const { "aria-level": level, "aria-posinset": posinset, "aria-setsize": setsize, isExpanded, isDetailsExpanded, isHidden } = row.props;
  return (0, import_jsx_runtime26.jsx)(Tr, Object.assign({ "aria-level": level, "aria-posinset": posinset, "aria-setsize": setsize, "aria-expanded": !!isExpanded, isHidden, className: css(className, isExpanded && table_default.modifiers.expanded, isDetailsExpanded && table_tree_view_default.modifiers.treeViewDetailsExpanded) }, props));
};
TreeRowWrapper.displayName = "TreeRowWrapper";

// node_modules/@patternfly/react-table/dist/esm/components/Table/Thead.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var import_react13 = __toESM(require_react());
var TheadBase = (_a) => {
  var { children, className, noWrap = false, innerRef, hasNestedHeader } = _a, props = __rest(_a, ["children", "className", "noWrap", "innerRef", "hasNestedHeader"]);
  return (0, import_jsx_runtime27.jsx)("thead", Object.assign({ className: css(table_default.tableThead, className, noWrap && table_default.modifiers.nowrap, hasNestedHeader && table_default.modifiers.nestedColumnHeader), ref: innerRef }, props, { children }));
};
var Thead = (0, import_react13.forwardRef)((props, ref) => (0, import_jsx_runtime27.jsx)(TheadBase, Object.assign({}, props, { innerRef: ref })));
Thead.displayName = "Thead";

// node_modules/@patternfly/react-table/dist/esm/components/Table/Tbody.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var import_react14 = __toESM(require_react());
var TbodyBase = (_a) => {
  var { children, className, isExpanded, innerRef, isEvenStriped = false, isOddStriped = false } = _a, props = __rest(_a, ["children", "className", "isExpanded", "innerRef", "isEvenStriped", "isOddStriped"]);
  return (0, import_jsx_runtime28.jsx)("tbody", Object.assign({ role: "rowgroup", className: css(table_default.tableTbody, className, isExpanded && table_default.modifiers.expanded, isOddStriped && table_default.modifiers.striped, isEvenStriped && table_default.modifiers.stripedEven), ref: innerRef }, props, { children }));
};
var Tbody = (0, import_react14.forwardRef)((props, ref) => (0, import_jsx_runtime28.jsx)(TbodyBase, Object.assign({}, props, { innerRef: ref })));
Tbody.displayName = "Tbody";

// node_modules/@patternfly/react-table/dist/esm/components/Table/Th.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var import_react16 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Table/table-scrollable.mjs
import "C:/Users/guillaumehouthoofd/Documents/Benoit/Epreuve_intégrée/ClubManager/front-end/node_modules/@patternfly/react-styles/css/components/Table/table-scrollable.css";
var table_scrollable_default = {
  "modifiers": {
    "borderRight": "pf-m-border-right",
    "borderLeft": "pf-m-border-left",
    "right": "pf-m-right",
    "inlineEnd": "pf-m-inline-end",
    "left": "pf-m-left",
    "inlineStart": "pf-m-inline-start"
  },
  "scrollInnerWrapper": "pf-v6-c-scroll-inner-wrapper",
  "scrollOuterWrapper": "pf-v6-c-scroll-outer-wrapper",
  "table": "pf-v6-c-table",
  "tableStickyCell": "pf-v6-c-table__sticky-cell"
};

// node_modules/@patternfly/react-styles/css/utilities/Accessibility/accessibility.mjs
import "C:/Users/guillaumehouthoofd/Documents/Benoit/Epreuve_intégrée/ClubManager/front-end/node_modules/@patternfly/react-styles/css/utilities/Accessibility/accessibility.css";
var accessibility_default = {
  "hidden": "pf-v6-u-hidden",
  "hiddenOnLg": "pf-v6-u-hidden-on-lg",
  "hiddenOnMd": "pf-v6-u-hidden-on-md",
  "hiddenOnSm": "pf-v6-u-hidden-on-sm",
  "hiddenOnXl": "pf-v6-u-hidden-on-xl",
  "hiddenOn_2xl": "pf-v6-u-hidden-on-2xl",
  "screenReader": "pf-v6-u-screen-reader",
  "screenReaderOnLg": "pf-v6-u-screen-reader-on-lg",
  "screenReaderOnMd": "pf-v6-u-screen-reader-on-md",
  "screenReaderOnSm": "pf-v6-u-screen-reader-on-sm",
  "screenReaderOnXl": "pf-v6-u-screen-reader-on-xl",
  "screenReaderOn_2xl": "pf-v6-u-screen-reader-on-2xl",
  "visible": "pf-v6-u-visible",
  "visibleOnLg": "pf-v6-u-visible-on-lg",
  "visibleOnMd": "pf-v6-u-visible-on-md",
  "visibleOnSm": "pf-v6-u-visible-on-sm",
  "visibleOnXl": "pf-v6-u-visible-on-xl",
  "visibleOn_2xl": "pf-v6-u-visible-on-2xl"
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/base/merge-props.js
var import_react15 = __toESM(require_react());
var import_mergeWith = __toESM(require_mergeWith());
function mergeProps(...props) {
  const firstProps = props[0];
  const restProps = props.slice(1);
  if (!restProps.length) {
    return (0, import_mergeWith.default)({}, firstProps);
  }
  return (0, import_mergeWith.default)((0, import_mergeWith.default)({}, firstProps), ...restProps, (a, b, key) => {
    if (key === "children") {
      if (a && b) {
        return (0, import_react15.cloneElement)(a, {
          children: b
        });
      }
      return Object.assign(Object.assign({}, b), a);
    }
    if (key === "className") {
      return css(a, b);
    }
    return void 0;
  });
}

// node_modules/@patternfly/react-tokens/dist/esm/c_table__sticky_cell_MinWidth.js
var c_table__sticky_cell_MinWidth = {
  "name": "--pf-v6-c-table__sticky-cell--MinWidth",
  "value": "8.75rem",
  "var": "var(--pf-v6-c-table__sticky-cell--MinWidth)"
};
var c_table_sticky_cell_MinWidth_default = c_table__sticky_cell_MinWidth;

// node_modules/@patternfly/react-tokens/dist/esm/c_table__sticky_cell_InsetInlineStart.js
var c_table__sticky_cell_InsetInlineStart = {
  "name": "--pf-v6-c-table__sticky-cell--InsetInlineStart",
  "value": "0",
  "var": "var(--pf-v6-c-table__sticky-cell--InsetInlineStart)"
};
var c_table_sticky_cell_InsetInlineStart_default = c_table__sticky_cell_InsetInlineStart;

// node_modules/@patternfly/react-tokens/dist/esm/c_table__sticky_cell_InsetInlineEnd.js
var c_table__sticky_cell_InsetInlineEnd = {
  "name": "--pf-v6-c-table__sticky-cell--InsetInlineEnd",
  "value": "0",
  "var": "var(--pf-v6-c-table__sticky-cell--InsetInlineEnd)"
};
var c_table_sticky_cell_InsetInlineEnd_default = c_table__sticky_cell_InsetInlineEnd;

// node_modules/@patternfly/react-table/dist/esm/components/Table/Th.js
var ThBase = (_a) => {
  var _b;
  var { children, className, component = "th", dataLabel, scope = "col", textCenter: textCenter2 = false, sort = null, modifier, select = null, expand: collapse = null, tooltip = "", tooltipProps, onMouseEnter: onMouseEnterProp = () => {
  }, width, visibility, innerRef, info: infoProps, isStickyColumn = false, hasRightBorder = false, hasLeftBorder = false, stickyMinWidth = "120px", stickyLeftOffset, stickyRightOffset, isSubheader = false, screenReaderText, "aria-label": ariaLabel } = _a, props = __rest(_a, ["children", "className", "component", "dataLabel", "scope", "textCenter", "sort", "modifier", "select", "expand", "tooltip", "tooltipProps", "onMouseEnter", "width", "visibility", "innerRef", "info", "isStickyColumn", "hasRightBorder", "hasLeftBorder", "stickyMinWidth", "stickyLeftOffset", "stickyRightOffset", "isSubheader", "screenReaderText", "aria-label"]);
  if (!children && !screenReaderText && !ariaLabel) {
    console.warn("Th: Table headers must have an accessible name. If the Th is intended to be visually empty, pass in screenReaderText. If the Th contains only non-text, interactive content such as a checkbox or expand toggle, pass in an aria-label.");
  }
  const [showTooltip, setShowTooltip] = (0, import_react16.useState)(false);
  const [truncated, setTruncated] = (0, import_react16.useState)(false);
  const cellRef = innerRef ? innerRef : (0, import_react16.createRef)();
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      !showTooltip && setShowTooltip(true);
    } else {
      showTooltip && setShowTooltip(false);
    }
    onMouseEnterProp(event);
  };
  let sortParams = null;
  if (sort) {
    if (sort.isFavorites) {
      sortParams = sortableFavorites({
        onSort: sort.onSort,
        columnIndex: sort.columnIndex,
        sortBy: sort.sortBy,
        tooltip,
        tooltipProps,
        ariaLabel: sort["aria-label"],
        favoriteButtonProps: sort.favoriteButtonProps
      })();
    } else {
      sortParams = sortable(children, {
        columnIndex: sort.columnIndex,
        column: {
          extraParams: {
            sortBy: sort.sortBy,
            onSort: sort === null || sort === void 0 ? void 0 : sort.onSort
          }
        },
        tooltip,
        tooltipProps
      });
    }
  }
  const selectParams = select ? selectable(children, {
    rowData: {
      selected: select.isSelected,
      disableSelection: select === null || select === void 0 ? void 0 : select.isDisabled,
      props: select === null || select === void 0 ? void 0 : select.props
    },
    column: {
      extraParams: {
        onSelect: select === null || select === void 0 ? void 0 : select.onSelect,
        selectVariant: "checkbox",
        allRowsSelected: select.isSelected,
        isHeaderSelectDisabled: !!select.isHeaderSelectDisabled
      }
    },
    tooltip,
    tooltipProps
  }) : null;
  const collapseParams = collapse ? collapsible(children, {
    column: {
      extraParams: {
        onCollapse: collapse === null || collapse === void 0 ? void 0 : collapse.onToggle,
        allRowsExpanded: !collapse.areAllExpanded,
        collapseAllAriaLabel: ""
      }
    }
  }) : null;
  const widthParams = width ? cellWidth(width)() : null;
  const visibilityParams = visibility ? classNames(...visibility.map((vis) => Visibility[vis]))() : null;
  let transformedChildren = (sortParams === null || sortParams === void 0 ? void 0 : sortParams.children) || (selectParams === null || selectParams === void 0 ? void 0 : selectParams.children) || (collapseParams === null || collapseParams === void 0 ? void 0 : collapseParams.children) || children;
  let infoParams = null;
  if (infoProps) {
    infoParams = info(infoProps)(transformedChildren);
    transformedChildren = infoParams.children;
  }
  const merged = mergeProps(sortParams, selectParams, collapseParams, widthParams, visibilityParams, infoParams);
  const {
    // ignore the merged children since we transform them ourselves so we can wrap it with info
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    children: mergedChildren = null,
    // selectable adds this but we don't want it
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isVisible = null,
    className: mergedClassName = "",
    component: MergedComponent = component
  } = merged, mergedProps = __rest(merged, ["children", "isVisible", "className", "component"]);
  (0, import_react16.useEffect)(() => {
    setTruncated(cellRef.current.offsetWidth < cellRef.current.scrollWidth);
  }, [cellRef]);
  const cell = (0, import_jsx_runtime29.jsx)(MergedComponent, Object.assign({ tabIndex: sort || select || !truncated ? -1 : 0, onFocus: tooltip !== null ? onMouseEnter : onMouseEnterProp, onBlur: () => setShowTooltip(false), "data-label": dataLabel, onMouseEnter: tooltip !== null ? onMouseEnter : onMouseEnterProp, scope: component === "th" ? scope : null, ref: cellRef, "aria-label": ariaLabel, className: css(table_default.tableTh, className, textCenter2 && table_default.modifiers.center, isSubheader && table_default.tableSubhead, isStickyColumn && table_scrollable_default.tableStickyCell, hasRightBorder && table_scrollable_default.modifiers.borderRight, hasLeftBorder && table_scrollable_default.modifiers.borderLeft, modifier && table_default.modifiers[modifier], ((_b = sort === null || sort === void 0 ? void 0 : sort.favoriteButtonProps) === null || _b === void 0 ? void 0 : _b.favorited) && table_default.modifiers.favorited, mergedClassName) }, mergedProps, props, isStickyColumn && {
    style: Object.assign({ [c_table_sticky_cell_MinWidth_default.name]: stickyMinWidth ? stickyMinWidth : void 0, [c_table_sticky_cell_InsetInlineStart_default.name]: stickyLeftOffset ? stickyLeftOffset : 0, [c_table_sticky_cell_InsetInlineEnd_default.name]: stickyRightOffset ? stickyRightOffset : 0 }, props.style)
  }, { children: transformedChildren || screenReaderText && (0, import_jsx_runtime29.jsx)("span", { className: accessibility_default.screenReader, children: screenReaderText }) }));
  const canMakeDefaultTooltip = tooltip === "" ? typeof transformedChildren === "string" : true;
  const childControlsTooltip = sortParams || selectParams;
  return tooltip !== null && canMakeDefaultTooltip && !childControlsTooltip && showTooltip ? (0, import_jsx_runtime29.jsxs)(import_jsx_runtime29.Fragment, { children: [cell, (0, import_jsx_runtime29.jsx)(Tooltip, Object.assign({ triggerRef: cellRef, content: tooltip || tooltip === "" && children, isVisible: true }, tooltipProps))] }) : cell;
};
var Th = (0, import_react16.forwardRef)((props, ref) => (0, import_jsx_runtime29.jsx)(ThBase, Object.assign({}, props, { innerRef: ref })));
Th.displayName = "Th";

// node_modules/@patternfly/react-table/dist/esm/components/Table/Td.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var import_react17 = __toESM(require_react());

// node_modules/@patternfly/react-table/dist/esm/components/Table/utils/decorators/draggable.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var draggable = (value, { rowData }) => {
  const { id } = rowData;
  return {
    className: "",
    children: (0, import_jsx_runtime30.jsx)(DraggableCell, { id })
  };
};

// node_modules/@patternfly/react-table/dist/esm/components/Table/Td.js
var TdBase = (_a) => {
  var { children, className, isActionCell = false, component = "td", dataLabel, textCenter: textCenter2 = false, modifier, select = null, actions = null, expand = null, treeRow: treeRowProp = null, compoundExpand: compoundExpandProp = null, noPadding, width, visibility, innerRef, favorites = null, draggableRow: draggableRowProp = null, tooltip = "", onMouseEnter: onMouseEnterProp = () => {
  }, isStickyColumn = false, hasRightBorder = false, hasLeftBorder = false, stickyMinWidth = "120px", stickyLeftOffset, stickyRightOffset } = _a, props = __rest(_a, ["children", "className", "isActionCell", "component", "dataLabel", "textCenter", "modifier", "select", "actions", "expand", "treeRow", "compoundExpand", "noPadding", "width", "visibility", "innerRef", "favorites", "draggableRow", "tooltip", "onMouseEnter", "isStickyColumn", "hasRightBorder", "hasLeftBorder", "stickyMinWidth", "stickyLeftOffset", "stickyRightOffset"]);
  const [showTooltip, setShowTooltip] = (0, import_react17.useState)(false);
  const [truncated, setTruncated] = (0, import_react17.useState)(false);
  const cellRef = innerRef ? innerRef : (0, import_react17.createRef)();
  const onMouseEnter = (event) => {
    if (event.target.offsetWidth < event.target.scrollWidth) {
      !showTooltip && setShowTooltip(true);
    } else {
      showTooltip && setShowTooltip(false);
    }
    onMouseEnterProp(event);
  };
  const selectParams = select ? selectable(children, {
    rowIndex: select.rowIndex,
    rowData: {
      selected: select.isSelected,
      disableSelection: select === null || select === void 0 ? void 0 : select.isDisabled,
      props: select === null || select === void 0 ? void 0 : select.props
    },
    column: {
      extraParams: {
        onSelect: select === null || select === void 0 ? void 0 : select.onSelect,
        selectVariant: select.variant || "checkbox"
      }
    }
  }) : null;
  const favoriteParams = favorites ? favoritable(null, {
    rowIndex: favorites === null || favorites === void 0 ? void 0 : favorites.rowIndex,
    rowData: {
      favorited: favorites.isFavorited,
      favoritesProps: favorites === null || favorites === void 0 ? void 0 : favorites.props
    },
    column: {
      extraParams: {
        onFavorite: favorites === null || favorites === void 0 ? void 0 : favorites.onFavorite
      }
    }
  }) : null;
  const draggableParams = draggableRowProp !== null ? draggable(null, {
    rowData: {
      id: draggableRowProp.id
    }
  }) : null;
  const actionParamsFunc = actions ? cellActions(actions.items, null, null) : null;
  const actionParams = actionParamsFunc ? actionParamsFunc(null, {
    rowIndex: actions === null || actions === void 0 ? void 0 : actions.rowIndex,
    rowData: {
      disableActions: actions === null || actions === void 0 ? void 0 : actions.isDisabled
    },
    column: {
      extraParams: {
        dropdownPosition: actions === null || actions === void 0 ? void 0 : actions.dropdownPosition,
        dropdownDirection: actions === null || actions === void 0 ? void 0 : actions.dropdownDirection,
        menuAppendTo: actions === null || actions === void 0 ? void 0 : actions.menuAppendTo,
        actionsToggle: actions === null || actions === void 0 ? void 0 : actions.actionsToggle
      }
    }
  }) : null;
  const expandableParams = expand !== null ? collapsible(null, {
    rowIndex: expand.rowIndex,
    columnIndex: expand === null || expand === void 0 ? void 0 : expand.columnIndex,
    rowData: {
      isOpen: expand.isExpanded
    },
    column: {
      extraParams: {
        onCollapse: expand === null || expand === void 0 ? void 0 : expand.onToggle,
        expandId: expand === null || expand === void 0 ? void 0 : expand.expandId
      }
    }
  }) : null;
  const compoundParams = compoundExpandProp !== null ? compoundExpand({
    title: children,
    props: {
      isOpen: compoundExpandProp.isExpanded
    }
  }, {
    rowIndex: compoundExpandProp === null || compoundExpandProp === void 0 ? void 0 : compoundExpandProp.rowIndex,
    columnIndex: compoundExpandProp === null || compoundExpandProp === void 0 ? void 0 : compoundExpandProp.columnIndex,
    column: {
      extraParams: {
        onExpand: compoundExpandProp === null || compoundExpandProp === void 0 ? void 0 : compoundExpandProp.onToggle,
        expandId: compoundExpandProp === null || compoundExpandProp === void 0 ? void 0 : compoundExpandProp.expandId
      }
    }
  }) : null;
  const widthParams = width ? cellWidth(width)() : null;
  const visibilityParams = visibility ? classNames(...visibility.map((vis) => Visibility[vis]))() : null;
  const treeRowParams = treeRowProp !== null ? treeRow(treeRowProp.onCollapse, treeRowProp.onCheckChange, treeRowProp.onToggleRowDetails)({
    title: children
  }, {
    rowIndex: treeRowProp.rowIndex,
    rowData: {
      props: treeRowProp.props
    }
  }) : null;
  const merged = mergeProps(selectParams, actionParams, expandableParams, compoundParams, widthParams, visibilityParams, favoriteParams, treeRowParams, draggableParams);
  const {
    // selectable adds this but we don't want it
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isVisible = null,
    children: mergedChildren = null,
    className: mergedClassName = "",
    component: MergedComponent = component
  } = merged, mergedProps = __rest(merged, ["isVisible", "children", "className", "component"]);
  const treeTableTitleCell = className && className.includes(table_tree_view_default.tableTreeViewTitleCell) || mergedClassName && mergedClassName.includes(table_tree_view_default.tableTreeViewTitleCell);
  (0, import_react17.useEffect)(() => {
    setTruncated(cellRef.current.offsetWidth < cellRef.current.scrollWidth);
  }, [cellRef]);
  const cell = (0, import_jsx_runtime31.jsx)(MergedComponent, Object.assign({ tabIndex: (select || !truncated) && modifier !== "truncate" ? -1 : 0 }, !treeTableTitleCell && { "data-label": dataLabel }, { onFocus: tooltip !== null ? onMouseEnter : onMouseEnterProp, onBlur: () => setShowTooltip(false), onMouseEnter: tooltip !== null ? onMouseEnter : onMouseEnterProp, className: css(table_default.tableTd, className, isActionCell && table_default.tableAction, textCenter2 && table_default.modifiers.center, noPadding && table_default.modifiers.noPadding, isStickyColumn && table_scrollable_default.tableStickyCell, hasRightBorder && table_scrollable_default.modifiers.borderRight, hasLeftBorder && table_scrollable_default.modifiers.borderLeft, table_default.modifiers[modifier], draggableParams && table_default.tableDraggable, mergedClassName), ref: cellRef }, mergedProps, props, isStickyColumn && {
    style: Object.assign({ [c_table_sticky_cell_MinWidth_default.name]: stickyMinWidth ? stickyMinWidth : void 0, [c_table_sticky_cell_InsetInlineStart_default.name]: stickyLeftOffset ? stickyLeftOffset : 0, [c_table_sticky_cell_InsetInlineEnd_default.name]: stickyRightOffset ? stickyRightOffset : 0 }, props.style)
  }, { children: mergedChildren || children }));
  const canMakeDefaultTooltip = tooltip === "" ? typeof children === "string" : true;
  return tooltip !== null && canMakeDefaultTooltip && showTooltip ? (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, { children: [cell, (0, import_jsx_runtime31.jsx)(Tooltip, { triggerRef: cellRef, content: tooltip || tooltip === "" && children, isVisible: true })] }) : cell;
};
var Td = (0, import_react17.forwardRef)((props, ref) => (0, import_jsx_runtime31.jsx)(TdBase, Object.assign({}, props, { innerRef: ref })));
Td.displayName = "Td";

// node_modules/@patternfly/react-table/dist/esm/components/Table/Caption.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var Caption = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime32.jsx)("caption", Object.assign({ className: css(table_default.tableCaption, className) }, props, { children }));
};
Caption.displayName = "Caption";

// node_modules/@patternfly/react-table/dist/esm/components/Table/OuterScrollContainer.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var OuterScrollContainer = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({ className: css(className, table_scrollable_default.scrollOuterWrapper) }, props, { children }));
};
OuterScrollContainer.displayName = "OuterScrollContainer";

// node_modules/@patternfly/react-table/dist/esm/components/Table/InnerScrollContainer.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var InnerScrollContainer = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime34.jsx)("div", Object.assign({ className: css(className, table_scrollable_default.scrollInnerWrapper) }, props, { children }));
};
InnerScrollContainer.displayName = "InnerScrollContainer";
export {
  ActionsColumn,
  Caption,
  CollapseColumn,
  DraggableCell,
  EditableSelectInputCell,
  EditableTextCell,
  ExpandableRowContent,
  FavoritesCell,
  HeaderCellInfoWrapper,
  InnerScrollContainer,
  OuterScrollContainer,
  RowSelectVariant,
  RowWrapper,
  SelectColumn,
  SortByDirection,
  SortColumn,
  Table,
  TableContext,
  TableGridBreakpoint,
  TableText,
  TableTextVariant,
  TableVariant,
  Tbody,
  Td,
  Th,
  Thead,
  Tr,
  TreeRowWrapper,
  Visibility,
  WrapModifier,
  applyCellEdits,
  breakWord,
  calculateColumns,
  cancelCellEdits,
  capitalize,
  cellActions,
  cellWidth,
  classNames,
  collapsible,
  compoundExpand,
  defaultTitle,
  editable,
  emptyCol,
  emptyTD,
  expandable,
  expandedRow,
  favoritable,
  fitContent,
  getErrorTextByValidator,
  headerCol,
  info,
  isRowExpanded,
  mapOpenedRows,
  mapProps,
  nowrap,
  parentId,
  scopeColTransformer,
  selectable,
  sortable,
  sortableFavorites,
  textCenter,
  toCamel,
  treeRow,
  truncate,
  validateCellEdits,
  wrappable
};
//# sourceMappingURL=@patternfly_react-table.js.map
